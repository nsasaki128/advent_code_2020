# Advent of Code 2020 Writeup
解いてみたので雑なWriteupを残しておく。

最初スネークケースを使っていたが、pythonってキャメルケースだったかと思い、途中からキャメルケースに変更。

## Day 1: Report Repair
単純なループの計算
### Part One

2変数の和が2020になればよい。

2020 = 値のsetを用意し、現在の値がこのsetに存在すれば良い。

答は(現在の値)\*(2020=現在の値)で出力

O(n)
### Part Two
3変数の和が2020になればよい。

入力が200と小さかったため、三重ループの総当たりで解いた。

O(n^3)


## Day 2: Password Philosophy
条件比較
### Part One
パースが少し面倒。

当該文字の出現回数をカウントし条件を満たすか確認。

満たせば+1

### Part Two
指定場所が当該の値かを確認し、xorを取り真になるかを確認。

満たせば+1


## Day 3: Toboggan Trajectory
二次元配列に対するアクセス
### Part One
二次元配列として取得。

列に対して行\*3を列の長さで割った余りを見て#なら答えに+1

### Part Two
列に対して行\*[1, 3, 5, 7]を列の長さで割った余りをそれぞれ見て#なら答えに+1

偶数行を対象としと行/2の列を列の長さで割った余りを見て#なら答えに+1

## Day 4: Passport Processing
ルールに基づくバリデーション
### Part One

空行が来たら次の塊と捉える。

各行は空白でトリミング。

cidは無視として、それ以外の7つのフィールドが全て存在したら+1

### Part Two

各パラメーターごとに適正な値か調べる。全て適正ならば+1

実装するだけだが面倒くさい。

## Day 5: Binary Boarding
バイナリ演算
### Part One
二進表記で値を求める。

各行の値と現在の最大値から最大値を求める。
### Part Two
取り得る最大値は2^10-1=1023

0から1024までのsetをつくり、出てきたパスポートの値を除いていく。

最終的に残った値のうち±1の値がこのsetにないものが答え。

## Day 6: Custom Customs
集合演算
### Part One
空行が来たら次の塊と捉える。

塊内で存在する文字の数を数える。

setを用意し、各文字を追加していき最後にsetのlenを出せば良い。

これらを塊ごとに足し合わせる。
### Part Two
行ごとに存在する文字のsetを作り、塊ないでそれらのandをとればよい。

## Day 7: Handy Haversacks
有向グラフの演算
### Part One
パースが面倒。

containで文字列をsplitし、前半は親、後半は子とする。

バッグの名前はbagsまたはbagを取り除き両端の空白を除く。

子に関しては"."でsplitし、最初の1文字目が親の持つバッグ数、2文字目以降は親と同じようにしてバッグの名前を抽出する。

※幸いにして、今回の入力においてバッグ数は1桁だけ。

バッグの含む含まれるのグラフを作る。

当該文字列を子に持つバッグの数を調べれば良い。

グラフ構築後は当該バッグを起点として、DFSで親をたどっていく。

当該文字列を含め訪ねたノードをsetとしてもっておき、すでに訪ねたノードはスキップ

上記のsetから当該文字列分を除くため、setのlen-1が答え。

最悪のケースでもすべてのノードを一回訪れるだけなのでO(N)
### Part Two
今度は当該文字列の子方向を調べていく。

バッグの子孫の数は、バッグの子ごとにそのバッグの数+そのバッグの数\*そのバッグの子孫の数=当該バックの数\*(1+当該バッグの持つ子孫バッグの数)となる。

DFSで求める。毎回計算するのは無駄なので、バッグごとの子孫の数はメモ化する。

子をもたないバッグから順に求まっていく。

最悪のケースでもすべてのノードを一回訪れるだけなのでO(N)
## Day 8: Handheld Halting
アセンブリの模倣とループの検出
### Part One
命令通りに実施するだけ。

一度訪れた命令の行を再び訪れたら、その時のaccumulatorの値を出力

O(N)
### Part Two
あまり美しくない解き方な気がする。

jmpとnopの命令に関して、一つずつ書き換えたパターンで最後までたどり着くかを試す。

jmpとnopの命令の数がO(N)、一回の調査がO(N)よりO(N^2)
## Day 9: Encoding Error
区間に対する演算
### Part One
キューを用いて長さ25のリストをキープする。

要求されるキューの長さは高々25のため、listでも速度にそこまで大きな問題はないが。。

次の値が来たら、過去の25でDay 1 Part Oneの解き方で値が存在するかを確認する。

存在しなければそれが答え、存在するときは新しく来た値をenqueueに追加し、dequeueする
### Part Two
入力全体のを保存する配列を用意する。

上記の部分列でPart Oneの解が総和になるものを見つけ、その部分列内の最小値と最大値の和を求める。

愚直に全部の組み合わせだとO(N^3)となるので（始点と終点の組み合わせがN^2で総和を求めるのにN）、計算量を減らす。

0からの累積和を前もって計算すれば、総和の計算が終点の累積和-始点の累積和でO(1)となるので、O(N^2)で解ける。

今回は入力が全て正のため、しゃくとり法を使ってO(N)で解いた。

入力も1000とそこまで多くないので、累積和を使っても良い気がする。

## Day 10: Adapter Array
配列のソートと漸化式の処理
### Part One
0と入力の最大値に3を追加した配列Aを用意する。

joltageの繋ぎ方は1, 2, 3のいずれかしかないため、Aをsortして一つ手前との差を調べていけば良い。

差が1の数と差が3の数を求め、掛け合わせたのが答え。

差の配列 diffs ([0, 0, 0, 0])を用意し、差の値が配列のインデックスとしてインクリメントすれば良い。

diffs[1]\*diffs[3]が答え。

O(N logN)
### Part Two
Part One 同様のソートした配列Aを利用する。

入力の最大+6の大きさの全てが0の配列Bを用意する。配列Bの大きさは最大でも毎回3ずつ増えるパターンのため、入力数\*3とそこまで大きくない

配列Bの2番目の要素のみを1とする。

アプローチ方法は3か2か1かでjoltageを繋ぐため

B[i] = B[i-1] + B[i-2] + B[i-3]

を満たす。

i=1, 2の際の場合分けをなくすため、インデックスを2右にして解いた。

## Day 11: Seating System
収束までの反復処理
### Part One
座席が収束するのを調べる。

周囲を調べてLと#の時は周囲を調べて条件を満たせば変更する。

.は何もしない。

調べる必要があるのは周囲の8マスのみ。

なるべくシンプルに条件を書きたいので、最初と最後の行及び列に"."を追加し、2文字目から最後の1つ前の文字に対して8方向を調べる。

8方向に関してもあらかじめ移動方向をまとめた配列を用意し、forループで処理をする。

一回の更新処理は全てのマスを調べるのでO(MN) M, Nはそれぞれ行と列の数。

収束するまでに処理を繰り返す回数は、、、わからない。
### Part Two
今度は隣ではなく各方向に対して.をスキップして一番近くにあるLまたは#を調べる。

※どちらもない場合はLとして考える。

単純に各マスごとに8方向を調べていくと、1マスあたりO(M+N)となる。

その場合は一回の更新処理はO(MN(M+N))となる。

各マスごとに調べて行かずに累積和の考えを利用してO(MN)の前処理を行うことで、一回の更新処理をO(MN)にすることができる。

各方向ごとに別の配列を用意したが、、、似たような処理でバグが多く発生し大変であった。

よりよい書き方はどうするのだろうか。。

## Day 12: Rain Risk
2x2の行列演算
### Part One
方向ベクトルと位置ベクトルを用意して、ルールに従ってそれぞれを変換。

最後は位置ベクトルのマンハッタン距離を求めれば良い。

LRの時のみ方向ベクトルが変更される。といっても90, 180, 270しかないみたいなので簡単。

シンプルな回転行列の演算。

Fは現在の方向分移動。

NEWSは絶対的な位置の移動。

### Part Two
ルールが少し変更される。

位置ベクトルの移動はFの際に方向ベクトル\*指定の移動距離のみとなる。

LRはPart Oneのまま。

NEWSが方向ベクトルの変更。


## Day 13: Shuttle Search
整数論、中国剰余定理
### Part One

.で区切られた数字の倍数で、最初の行で与えられた値を超える最小の値を計算する。

(計算した中での最小の値 - 最初の数字) * ,区切りの中の当該の数字

が答え。
### Part Two
一行目は無視

,で区切られた文字を配列IDを考える。

IDの値が数字の箇所に関しては、その数字の倍数となる数字にチェックを入れていき、配列のインデックス順に並ぶものを求める。

その中で最小の値が解。

2, x, 3, x, x, 5

の場合は

10, 12, 15

が条件を満たす。

これは

X ≡ 0 (mod 2)

X ≡ -2 (mod 3)

X ≡ -5 (mod 5)

を満たすXである。

答の存在が保証されているため、中国剰余定理よりIDの値はどの二つも互いに素である。

入力を見る限り今回は全部素数っぽい。

https://qiita.com/drken/items/ae02240cd1f8edfc86fd

を参考に実装すれば良い


## Day 14: Docking Data
ビット演算、数え上げ
### Part One
memの配列の大きさが不明のため、配列の代わりmapを用意して、キーがメモリアドレス、バリューをmaskした結果とする。

mem[xxx] = yyy

のyyyに対して現在のmaskをあてる。

うしろからN bit目が1ならばyyyと1のN bitシフトでorをとり、当該bitを1にする。

うしろからN bit目が0ならばyyyと1のN bitシフトをnotしたものでandをとり、当該bitを0にする。

最終的にmapのバリューの総和を取る。
### Part Two
mem[xxx] = yyy

yyyはそのままにxxxに対してmaskをあて、とりうる値のsetを計算する。

うしろからN bit目が1ならばxxxと1のN bitシフトでorをとり、当該bitを1にする。

うしろからN bit目がXならば当該bitは0も1もありえる。

まずは以下の二つを行う。

+ 後ろからN bit目が1の場合のxxxを更新。
+ 後ろからN bit目がXのNを収集。

更新したxxxをsetに加える。

先述のXとなるN bit目に対し、現状のsetに含まれる全ての数値に対して0となる場合、1となる場合のsetを求める。

現場のsetを新たに計算したsetで更新する。

mapのキーを[得られたsetの各値]、バリューをyyyとする。

最終的にmapのバリューの総和を取る。


## Day 15: Rambunctious Recitation
必要なデータの保持、漸化式
### Part One
入力は最初の値として受け取る。

新しい値は、ひとつ前の値が初見ならば0、そうでないならばひとつ前の値がその前に出た時との差分

入力が1,3,2の場合

1番目の出力: 1（入力）

2番目の出力: 3（入力）

3番目の出力: 2（入力）

4番目の出力: 0（2は初見の値のため）

5番目の出力: 0（0は初見の値のため）

6番目の出力: 1（0は5番目の前に4番目にあるため5-4=1）

7番目の出力: 5（1は6番目の前に1番目にあるため6-1=5）

8番目の出力: 0（5は初見の値のため）

値とそれが最後に出た順番をmapで保持。

現在の値がmapに存在すれば、それと現在の番号の差分が次の値

そうでなければ0が次の値とすれば良い

O(N)
### Part Two
ループ数を増やす。

O(N)だが3\*10^8と入力が大きいので、pythonだと1 min近くかかる。

余談だが競技プログラミングだと10^8を超えると1秒以内に問題が解けない目安と考えている。

数学的に解けるかと考えたがわからなかった。

解答後にredditのやりとりを見たが、やはりO(N)が想定解っぽい。


## Day 16: Ticket Translation
条件判定、バックトラッキング、枝刈り
### Part One
ちょっとパースが面倒

your ticketは無視

Day 4と似た感じ。

座席の説明で座席の範囲を覚え、nearby tickets以降でその範囲内にない座席の値を足し合わせる。
### Part Two
面倒くさい！

パース後の処理は5つの部分から構成される

your ticketとnearby ticketsは1行あたり全て同じ列数を持つ。

+ 座席名とその有効範囲を取得（classは1~3, 5~7など）
+ nearby ticketsから有効範囲外の座席を取得（今回は当該の行と列をtupleで持つsetに保持）
+ nearby ticketsの列ごとに座席名で有効なものを取得。ただし、無効な座席は無視（行と列のtupleが前述のsetに含まれるか確認）
+ 列と座席名の組み合わせをバックトラッキングでしらみ潰しに調査（枝狩りとして可能性のある座席名が少ない列から順に調べるとよい）
+ 座席名がdepartureから始まる座席名の列に該当するyour ticketの値の掛け算


ticketsの行、列をM, Nとすると計算量はO(MN^2+N^N)

- 入力の取得が座席名と自分の座席と近隣の座席のためO(N+N+MN) = O(MN)
- 有効範囲の取得がMN席に対して2Nの有効範囲を調査するため、O(MN\*2N) = O(MN^2)
- 枝狩りのため、列に対する座席名の候補数が少ない順にソートしているためO(NlogN)
- バックトラッキングでの組み合わせがN!通りあるためO(N^N)
  - スターリングの公式より

以上より、求める計算量はO(MN + MN^2 + NlogN + N^N) = O(MN^2 + N^N)

なお、今回の問題に関しては列に対する座席の候補数が少ない順に選べば解が得られる。そのため、O(MN^2 + NlogN)

Part Oneが簡単だったので油断したが、思いのほか実装が多くて大変であった。


## Day 17: Conway Cubes
多次元配列、境界の扱い
### Part One

状態変化を説明する図がミスリーディングなので注意

近くにactiveな物体がないとactiveにならない

一回の操作でactiveが広がるのは、元の入力から(x,y,z)がそれぞれ±1の範囲のみ

そのため、操作ごとに入力の各次元に対して最大の範囲でactiveが増えていく

入力はとあるxy平面のため、z軸の伸びは少ない（が面倒なのでxyと同じ数にした）

Day 11と同じテクニックを使い、境界の処理を簡単にした

あとはルールに従って実装して最後に#の数を数える

入力の行と列をM, N繰り返しの数をRとするとO(R^4 \* (M+N)^3)

三次元の配列の要素数がO( ( Max(M, N) + 2\*R )^3) = O((R(M+N))^3)

これに対する操作をR回繰り返すため O(R \* (R(M+N))^3) = O(R^4 \* (M+N)^3)

### Part Two
三次元が四次元になるだけ、わりと無駄があるので計算に時間はかかる

計算量は入力の行と列をM, N繰り返しの数をRとするとO(R^5 \* (M+N)^4)


## Day 18: Operation Order
字句解析、構文解析、抽象構文木
### Part One
一般と異なる優先規則の演算を実施する計算機を作る。

全ての入力列に対してこの演算規則で計算し、その答えの総和を求める。

トークナイザは入力行をNumber, \*, +, (, )に切り分ける配列にした。

※今回の入力規則だと、全ての空白を除去して、一文字ずつ順に取っていけば十分だが、数字は二桁以上が存在し、空白の存在が任意でも対応できる実装にした

+と\*の優先度がなく左から計算していけば良い。()の中だけは優先とする

再帰を使ったcalcを定義する。

次の演算のopと現在の計算結果curを保持して、現在のtokenの値に応じて以下の規則に従って読み進めていく

+ +または\*ならばopをtokenの値に切り替える
+ 数値の場合は、opに従ってcurにtokenの値の演算を行う
+ )の場合は、現在の計算結果と読み込み位置を返り値としてreturnする
+ (の場合はcalcを呼び出し、opに従ってcurにその演算結果に対して演算を行い、tokenの読み取り位置をcalcの演算結果まですすめる

最初のopとcurは+と0にし、最後まで読み終われば完了

文法に従わない計算は考慮外とする（面倒なため）

### Part Two
()を最優先、次に+をしてから\*を行う計算規則

ちょっと真面目に構文解析を行い、抽象構文木を作成した

※実際は演算結果を保持していけば、抽象構文木を作らなかっても大丈夫だったりする。が、作りたかったから作った！

再帰下降構文解析を以下のLL(1)文法で行う

- add = primary ( "+" primary )\*
- mul = add ( "\*" add )\*
- primary = number | "(" mul ")"

※文法の正しさは、実際に手で書けばわかる

※今回は読み取り位置を各関数の引数としたが、クロージャーを使ってこの引数をなくしても良いかもしれない

そしてtokenに対し、mulを実施すればよい。

あとは規則に従ってNodeを作り、抽象構文木を構成する

Nodeには型（数値、加算、乗算）と値、左の子Node l, 右の子Node rが存在する

calcでは型が数値なら保持している値を返す

型が演算処理ならlとrに対しcalcを実行し、その結果に対して型に応じた演算結果を返す


## Day 19: Monster Messages
文脈自由文法、正規表現、トポロジカルソート
### Part One
最初に文脈自由文法で記載されたルールがあり、後半の文字列の中でその文法に合致するものを数える

再帰がないため、この文法で作れるのは実は正規表現と同等

必要な正規表現を作れば良い

2: 1 3 | 4 5

の場合は、文法2に合致する正規表現は (1の正規表現, 3の正規表現|4の正規表現, 5の正規表現)となる

トポロジカルソートで呼び出し順を調べ、終端文字列から順に正規表現を作成していき、後半の入力の中で文法0にマッチする数を調べればよい

### Part Two
正規表現では表せない文法になる

文脈自由文法からプッシュダウンオートマトンを模倣しても良いのだが、、、面倒そうなので力技で解決した

8: 42 | 42 8

11: 42 31 | 42 11 31

からわかることは

文法8 42の文法を1回以上繰り返す

文法11 42の文法と31の文法をそれぞれ同じi(>0)回繰り返す

という文法である。

ただし、よくよく見てみると求める文法0は

0: 8 11

となっている。そのため、これらの文法を組み合わせると

42の文法を2回以上繰り返し、31の文法を1回以上42の文法未満で繰り返す文法が求める文法である

なので、文字列に対し先頭から可能なだけ42の文法にマッチしている文字列を取得、元から42の文法を取り除いた残りに対して、31の文法のマッチしている数を数え、それを調べれば良い

※42と31の文法が被っているともっと複雑になるが、、、そうはならなかったのでacceptとなった


## Day 20: Jurassic Jigsaw
幅優先探索、二次元配列の回転
### Part One
もとの正方形の辺に相当する箇所と同じ辺が、破片の辺同士が接する場所には存在しない

そのため、入力で得られる破片の辺をキーとし、破片のIDをバリューとするマップを用意し、キーに対するIDの数が1つのみの辺は元の正方形の辺であることがわかる

今回の問題は角に存在する四辺形のIDを探せば良いので、IDごとに上記のような辺の数を数え、それが2つであるIDが必要なIDである

得られたIDの値を全て掛け合わせればそれが答えである

なお、破片は回転と裏返しをして調整していくため、キーとする辺に関しては両方向から並べたものを利用する

整理された四辺形が以下の場合を考える

abc c23 ...  
def f56 ...  
ghi i89 ...  

ghi ...  
DEF ...  
GHI ...  

左上の破片では"abc", "cba", "cfi", "ifc", "ghi", "ihg", "adg", "gda"がキーとなる

上から1番左から2番目の破片が入力としては、以下の場合もあるため、両方向の検討が必要である

98i  
65f  
32c  

このとき、"cfi"と"ifc"が重なる必要がある

これによりダブりが生じるため、実際は角の四辺形はIDごとに存在するユニークな辺の数は4となる


### Part Two
今回の問題では接する辺の形がユニークとなっているため、多少楽だったりする

これは前回の例で言うと

abc c23 ...  
def f56 ...  
ghi i89 ...  

としたときに、

cAB  
fCD  
iEF  

のような辺は存在しないことを意味する

以下の3つの処理を行う必要がある

+ 元の正方形における破片の位置と形を求める
+ 破片から元の正方形を生成する
+ 元の正方形に存在する海の怪獣の数が最大の時にどれだけ存在するか求める

この再構成が大変だったりする

#### 元の正方形における破片の位置と形を求める

キューを用意し、順々に次の位置の候補を調べる

正しい向きが分かり次第、次の候補をキューに追加する

キューから次の位置の候補を取り出し、正しい向きを調べる

最初、キューにはPart Oneでわかった角のピースの一つを追加する

これを左上と仮定してすすめる（回転と反転を行うため、実際どれが左上の場所になっても問題ない）

正しい向きの条件は以下の通り

- 位置が正方形の辺相当の場所は、同一の辺をキーとするIDはひとつのみ
- 隣がわかっている辺はそれと合致する

正しい向きでない時は90度回転をする

360度回転しても正しい向きでない時は、反転する

再び360度回転しても見つからないケースはない。（これまでの類推が正しい限り）

正しい向きであることが分かり次第、その破片の存在するならば右と下の破片の候補と制約を追加する

今回調べた破片Aの右側に存在する破片BのIDはAの右側の辺をキーとし、Part Oneで求めた辺とIDのマップから取得できる

またBの左側の辺はAの右側の辺と一致するため、それを制約として追加する

下の破片に関しても同様に考えられる

#### 破片から元の正方形を生成する
破片の四辺を取り除きくっ付ければ良い

最終的な長さがどうなるか、どこが何に合致するかを考えながら作るのがやや面倒

#### 元の正方形に存在する海の怪獣の数が最大の時にどれだけ存在するか求める
怪獣の形を調べればわかるが、海の怪獣の形はエリアが被ることはない

元の四辺形を左上から調べ、怪獣の#の場所すべてに#が存在すれば怪獣が存在するのでその数を数える

90度ずつ回転させ、360度回転したら、反転させまた90度ずつ回転していく

トータル8回調べれば、怪獣の数が最大のパターンがわかる

あとは、正方形全体の#の数から怪獣の数\*15（怪獣の#の数）を引けばそれが答えである


## Day 21: 

### Part One

### Part Two

## Day 22: 

### Part One

### Part Two

## Day 23: 

### Part One

### Part Two

## Day 24: 

### Part One

### Part Two

## Day 25: 

### Part One

### Part Two

